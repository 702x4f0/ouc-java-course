%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \documentclass[hyperref={pdfpagelabels=false},compress,table]{beamer} % 在Mac下无法编译
\documentclass[compress,table]{beamer} % 在Mac下使用
% package for font
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text}  %%如果没有它，会有一些 tex 特殊字符无法正常使用，比如连字符。
\usepackage{xunicode,xltxtra}
\usepackage[BoldFont,SlantFont,CJKnumber,CJKchecksingle]{xeCJK}  % \CJKnumber{12345}: 一万二千三百四十五
\usepackage{CJKfntef}  %%实现对汉字加点、下划线等。
\usepackage{pifont}  % \ding{}
% package for math
\usepackage{amsfonts}

% package for graphics
\usepackage[americaninductors,europeanresistors]{circuitikz}
\usepackage{tikz}
\usetikzlibrary{plotmarks}  % placements=positioning
\usepackage{graphicx}  % \includegraphics[]{}
\usepackage{subfigure}  %%图形或表格并排排列
% package for table
\usepackage{colortbl,dcolumn}  %% 彩色表格
\usepackage{multirow}
\usepackage{multicol}
\usepackage{booktabs}
% package for code
\usepackage{fancyvrb}
\usepackage{listings}

% \usepackage{animate}
% \usepackage{movie15}

%%%%%
% setting for beamer
\usetheme{default} % Madrid（常用）, Copenhagen, AnnArbor, boxes（白色）, Frankfurt，Berkeley
\useoutertheme[subsection=true]{miniframes} % 使用Berkeley时注释本行
\usecolortheme{sidebartab}
\usefonttheme{serif}  %%英文使用衬线字体
% \setbeamertemplate{background canvas}[vertical
% shading][bottom=white,top=structure.fg!7] %%背景色，上25%的蓝，过渡到下白。
\setbeamertemplate{theorems}[numbered]
\setbeamertemplate{navigation symbols}{}  %% 去掉页面下方默认的导航条
\setbeamercovered{transparent}  %设置 beamer 覆盖效果

% 设置标题title背景色
% \setbeamercolor{title}{fg=black, bg=lightgray!60!white}
\setbeamercolor{title}{fg=white, bg=black!70!white}

% 设置每页小LOGO
\pgfdeclareimage[width=1cm]{ouc}{figures/static/ouc.pdf}
\logo{\pgfuseimage{ouc}{\vspace{-20pt}}}

% setting for font
%%\setCJKmainfont{Adobe Kaiti Std}
\setCJKmainfont{SimSun} 
%% \setCJKmainfont{FangSong_GB2312} 
%% \setmainfont{Apple Garamond}  %%苹果字体没有SmallCaps
\setCJKmainfont{SimSun} 
%FUNNY%\setCJKmainfont{DFPShaoNvW5-GB}  %%华康少女文字W5(P)
%FUNNY%\setCJKmainfont{FZJingLeiS-R-GB}  %%方正静蕾体
%FUNNY%\setmainfont{Purisa}
%\setsansfont[Mapping=tex-text]{Adobe Song Std}
     %如果装了Adobe Acrobat，可在font.conf中配置Adobe字体的路径以使用其中文字体。
     %也可直接使用系统中的中文字体如SimSun、SimHei、微软雅黑等。
     %原来beamer用的字体是sans family；注意Mapping的大小写，不能写错。
     %设置字体时也可以直接用字体名，以下三种方式等同：
     %\setromanfont[BoldFont={黑体}]{宋体}
     %\setromanfont[BoldFont={SimHei}]{SimSun}
     %\setromanfont[BoldFont={"[simhei.ttf]"}]{"[simsun.ttc]"}
% setting for graphics
\graphicspath{{figures/}}  %%图片路径
\renewcommand\figurename{图}

% setting for pdf
\hypersetup{% pdfpagemode=FullScreen,%
            pdfauthor={Xiaodong Wang},%
            pdftitle={Title},%
            CJKbookmarks=true,%
            bookmarksnumbered=true,%
            bookmarksopen=false,%
            plainpages=false,%
            colorlinks=true,%
            citecolor=green,%
            filecolor=magenta,%
            linkcolor=blue,%red(default)
            urlcolor=cyan}

% setting for fontspec
\XeTeXlinebreaklocale "zh"  %%表示用中文的断行
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt  %%多一点调整的空间
%%%%%

% font setting by xeCJK
\setCJKfamilyfont{NSimSun}{NSimSun}
\newcommand{\song}{\CJKfamily{NSimSun}}
%%%\setCJKfamilyfont{AdobeSongStd}{Adobe Song Std}
%%%\newcommand{\AdobeSong}{\CJKfamily{AdobeSongStd}}
\setCJKfamilyfont{FangSong}{FangSong_GB2312}
\newcommand{\fang}{\CJKfamily{FangSong}}
%%%\setCJKfamilyfont{AdobeFangsongStd}{Adobe Fangsong Std}
%%%\newcommand{\AdobeFang}{\CJKfamily{AdobeFangsongStd}}
\setCJKfamilyfont{SimHei}{SimHei}
\newcommand{\hei}{\CJKfamily{SimHei}}
%%%\setCJKfamilyfont{AdobeHeitiStd}{Adobe Heiti Std}
%%%\newcommand{\AdobeHei}{\CJKfamily{AdobeHeitiStd}}
\setCJKfamilyfont{KaiTi}{KaiTi}
\newcommand{\kai}{\CJKfamily{KaiTi}}
%%%\setCJKfamilyfont{AdobeKaitiStd}{Adobe Kaiti Std}
\newcommand{\AdobeKai}{\CJKfamily{AdobeKaitiStd}}
\setCJKfamilyfont{LiSu}{LiSu}
\newcommand{\li}{\CJKfamily{LiSu}}
\setCJKfamilyfont{YouYuan}{YouYuan}
\newcommand{\you}{\CJKfamily{YouYuan}}
\setCJKfamilyfont{FZJingLei}{FZJingLeiS-R-GB}
\newcommand{\jinglei}{\CJKfamily{FZJingLei}}
\setCJKfamilyfont{MSYH}{Microsoft YaHei}
\newcommand{\msyh}{\CJKfamily{MSYH}}

% 自定义颜色
\def\Red{\color{red}}
\def\Green{\color{green}}
\def\Blue{\color{blue}}
\def\Mage{\color{magenta}}
\def\Cyan{\color{cyan}}
\def\Brown{\color{brown}}
\def\White{\color{white}}
\def\Black{\color{black}}

\lstnewenvironment{javaCode}[1][]{% for Java
  \lstset{
    basicstyle=\tiny\ttfamily,%
    columns=flexible,%
    framexleftmargin=.7mm, %
    frame=shadowbox,%
    rulesepcolor=\color{cyan},%
    % frame=single,%
    backgroundcolor=\color{white},%
    xleftmargin=4\fboxsep,%
    xrightmargin=4\fboxsep,%
    numbers=left,numberstyle=\tiny,%
    numberblanklines=false,numbersep=7pt,%
    language=Java, %
    }\lstset{#1}}{}

\lstnewenvironment{shCode}[1][]{% for Java
  \lstset{
    basicstyle=\scriptsize\ttfamily,%
    columns=flexible,%
    framexleftmargin=.7mm, %
    frame=shadowbox,%
    rulesepcolor=\color{brown},%
    % frame=single,%
    backgroundcolor=\color{white},%
    xleftmargin=4\fboxsep,%
    xrightmargin=4\fboxsep,%
    numbers=left,numberstyle=\tiny,%
    numberblanklines=false,numbersep=7pt,%
    language=sh, %
    }\lstset{#1}}{}

\newcommand\ask[1]{\vskip 4bp \tikz \node[rectangle,rounded corners,minimum size=6mm,
  fill=white,]{\Cyan \includegraphics[height=1.5cm]{question} \Large \msyh #1};}

\newcommand\wxd[1]{\vskip 4bp \tikz \node[rectangle,minimum size=6mm,
  fill=blue!60!white,]{\White \ding{118} \msyh #1};}

\newcommand\xyy[1]{\vskip 2bp \tikz \node[rectangle,minimum size=3mm,
  fill=black!80!white,]{\White \msyh\scriptsize #1};}

\newcommand\cxf[1]{\vskip 4bp \tikz \node[rectangle,rounded corners,minimum size=6mm,
  fill=orange!60!white,]{\White \ding{42} \msyh #1};}

\newcommand\samp[1]{\vskip 2bp \tikz \node[rectangle,minimum size=3mm,
  fill=white!100!white,]{\Mage\msyh \small CODE \ding{231} \Black #1};\vskip -8bp}

\newcommand\zhyfly[1]{\tikz \node[rectangle,rounded corners,minimum size=6mm,ball
  color=red!25!blue,text=white,]{#1};}

\newcommand\pno[1]{\tikz \node[rectangle,rounded corners,minimum size=1mm,
  fill=yellow!50!black,text=white,]{\msyh\scriptsize P. #1};}

\setbeamerfont{frametitle}{series=\msyh} % 修改Beamer标题字体

\makeatletter
\newcommand{\Extend}[5]{\ext@arrow 0099{\arrowfill@#1#2#3}{#4}{#5}}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \titlepage
\title[KevinW@OUC]{\hei {\huge Java 应用程序设计}\\  
  简单线程编程}
\author[王晓东]{王晓东\\
  \href{mailto:wxd2870@163.com}{\footnotesize wxd2870@163.com}}
\institute[中国海洋大学]{\small 中国海洋大学}
\date{\today}
\titlegraphic{\vspace{-6em}\includegraphics[height=6cm]{static/ouc.pdf}\vspace{-6em}}
%%%%%
\begin{document}
%% Delete this, if you do not want the table of contents to pop up at
%% the beginning of each subsection:
\AtBeginSection[]{                              % 在每个Section前都会加入的Frame
  \frame<handout:0>{
    \frametitle{\textbf{\hei 接下来…}}
    \tableofcontents[currentsection]
  }
}  %

\AtBeginSubsection[]                            % 在每个子段落之前
{
  \frame<handout:0>                             % handout:0 表示只在手稿中出现
  {
    \frametitle{\textit{\hei 接下来…}}\small
    \tableofcontents[current,currentsubsection] % 显示在目录中加亮的当前章节
  }
}
 \frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{参考书目}
\begin{enumerate}
\item 张利国、刘伟[编著], Java SE应用程序设计, 北京理工大学出版社, 2007.10.

\end{enumerate}  
\end{frame}

\begin{frame}
\frametitle{本章学习目标}
\begin{enumerate}
\item 线程基础
\item 线程控制
\item 线程的同步（后续课程）
\item 多线程编程问题（后续课程）
\end{enumerate}  
\end{frame}

\section*{大纲}
\frame{\frametitle{大纲} \tableofcontents }

\section{线程基础}
% \subsection{线程的概念模型}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{什么是线程}

根据多任务原理，在一个程序内部也可以实现多个任务（顺序控制流）的并发执行，其中每个任务被
称为线程（Thread）。更专业的表述为：{\hei 线程是程序内部的顺序控制流。}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程和进程的区别}
\begin{enumerate}
\item 每个进程都有独立的代码和数据空间（进程上下文），进程切换的开销大。
\item 线程作为轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数
  器（PC），线程切换的开销小。
\item 多进程——在操作系统中能同时运行多个任务（程序）。
\item 多线程——在同一应用程序中有多个顺序流同时执行。
\end{enumerate}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程的概念模型}
在Java语言中，多线程的机制通过虚拟CPU来实现。
\begin{enumerate}
\item 虚拟的CPU，由java.lang.Thread类封装和虚拟；
\item CPU所执行的代码，传递给Thread类对象；
\item CPU所处理的数据，传递给Thread类代码对象。
\end{enumerate}
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{fig01.pdf}
\end{figure}
\end{frame}

% \subsection{创建线程}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{创建线程}

Java的线程是通过java.lang.Thread类来实现的。每个线程都是通过某个特定Thread对象所对应的方
法run( )来完成其操作的，方法run()称为线程体。

\begin{javaCode}
public class TestThread1 {
  public static void main(String args[]) {
    Runner1 r = new Runner1();
    Thread t = new Thread(r);
    t.start();
  }
}
class Runner1 implements Runnable {
  public void run() {
    for(int i=0; i<30; i++) {
      System.out.println("No. " + i);
    }
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{创建和启动线程的一般步骤}
\begin{enumerate}
\item 定义一个类实现Runable接口，重写其中的run()方法，加入所需的处理逻辑；
\item 创建Runable接口实现类的对象；
\item 创建Thread类的对象（封装Runable接口实现类型对象）；
\item 调用Thread对象的start()方法，启动线程。
\end{enumerate}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{多线程}

Java中引入线程机制的目的在于实现{\hei 多线程（Multi-Thread）}。
\xyy{使用多线程}
\begin{javaCode}
public class TestThread2 {
  public static void main(String args[]) {
    Runner2 r = new Runner2();
    Thread t1 = new Thread(r);
    Thread t2 = new Thread(r);
    t1.start();
    t2.start();
  }
}
class Runner2 implements Runnable {
  public void run() {
    for(int i=0; i<20; i++) {
      String s = Thread.currentThread().getName(); //获取当前运行中的线程对象
      System.out.println(s + ": " + i);
    }
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{多线程共享代码和数据}

多线程之间可以共享代码和数据。
\begin{javaCode}
Runner2 r = new Runner2();
Thread t1 = new Thread(r);
Thread t2 = new Thread(r);
\end{javaCode}
\begin{table}
\footnotesize
\setlength{\extrarowheight}{1.2mm}
\rowcolors[]{1}{blue!20}{blue!10}
\begin{tabular}{c|c|c|c}
{\bf 线程} & {\bf 虚拟CPU} & {\bf 代码} & {\bf 数据} \\
t1 & Thread类对象 & Runner2类中的run()方法 & Runnable类型对象r \\
t2 & Thread类对象 & Runner2类中的run()方法 & Runnable类型对象r \\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{创建线程的第二种方式}

\xyy{直接继承Thread类创建线程}
\begin{javaCode}
public class TestThread3 {
  public static void main(String args[]) {
    Thread t = new Runner3();
    t.start();
  }
}
class Runner3 extends Thread {
  public void run() {
    for(int i=0; i<30; i++) {
      System.out.println("No. " + i);
    }
  }
}
\end{javaCode}
\wxd{第二种创建线程的方式}
\begin{enumerate}
\item 定义一个类继承Thread类，重写其中的run()方法，加入所需的处理逻辑；
\item 创建该Thread类的对象；
\item 调用该对象的start()方法。
\end{enumerate}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{两种创建线程的方式比较}
\wxd{使用Runnable接口创建线程}
\begin{itemize}
\item 可以将虚拟CPU、代码和数据分开，形成清晰的模型；
\item 线程体run()方法所在的类还可以从其他类继承一些有用的属性或方法；
\item 有利于保持程序风格的一致性。
\end{itemize}
\wxd{直接继承Thread类创建线程}
\begin{itemize}
\item Thread子类无法再从其他类继承；
\item 编写简单，run()方法的当前对象就是线程对象，可直接操纵。
\end{itemize}
\end{frame}

% \subsection{后台线程}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{后台线程}

\wxd{相关概念}\\
\xyy{后台处理} 也称为后台运行，是指在分时处理或多任务系统中，当实时、会话式、高优先级或需
迅速相应的计算机程序不再使用系统资源时，计算机去执行较低优先级程序的过程。批量处理、文件
打印通常采取后台处理的形式。

\xyy{后台线程} 是指那些在后台运行的，为其他线程提供服务的功能，如JVM的垃圾回收线程等，后
台线程也称为守护线程（Daemon Thread）。

\xyy{用户线程} 和后台线程相对应，其他完成用户任务的线程可称为“用户线程”。
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{后台线程}
Thread类提供的与后台线程相关的方法包括：
\begin{enumerate}
\item 测试当前线程是否为守护线程，如果是则返回true，否则返回false。
\begin{javaCode}
public final boolean isDaemon()
\end{javaCode}
\item 将当前线程标记为守护线程或用户线程，本方法必须在启动线程前调用。
\begin{javaCode}
public final void setDaemon(Boolean on)
\end{javaCode}
\end{enumerate}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{后台线程}
\xyy{使用后台线程}
%% \samp{TestDaemonThread.java}
\begin{javaCode}
public class TestDaemonThread {
  public static void main(String[] args) {
    Thread t1 = new MyRunner(10);
    t1.setName("用户线程t1");
    t1.start();
    Thread t2 = new MyRunner(10000);
    t2.setDaemon(true);
    t2.setName("后台线程t2");
    t2.start();
    for(int i = 0; i < 10; i++) {
      System.out.println(Thread.currentThread().getName() + ": " + i);
    }
    System.out.println("主线程结束");
  }
}
class MyRunner extends Thread {
  private int n;
  public MyRunner(int n) {
    this.n = n;
  }
  public void run() {
    for(int i = 0; i < n; i++) {
      System.out.println(this.getName() + ": " + i);
    }
    System.out.println(this.getName() + "结束");
  }
}  
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{后台线程}

\wxd{对上述代码的分析}

{\Mage 后台线程线程t2并没有如预期的输出数字$0$-$9999$，而是提前终止。这是因为，待用户线
  程（这里包括主线程和线程t1）全部运行结束后，JVM检测到只剩下后台线程在运行的时候，就退出
  了当前应用程序的运行。}

将上述代码中的“t2.setDaemon(true);”注释后，编译运行程序进行比较。

\end{frame}

% \subsection{GUI线程}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{GUI线程}

GUI程序运行过程中，系统会自动创建若干GUI线程，以提供所需的功能，包括{\Blue\it 窗体显示和重绘、GUI
事件处理、关闭抽象窗口工具集等}。
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{GUI线程}

\xyy{使用GUI线程示例}
\samp{TestGUIThread.java: Part 1}
\begin{javaCode}
import java.awt.*;
import java.awt.event.*;

public class TestGUIThread {
  public static void main(String[] args) throws Exception {
    Frame f = new Frame();
    Button b = new Button("Press Me");
    MyMonitor mm = new MyMonitor();
    b.addActionListener(mm);
    f.addWindowListener(mm);
    f.add(b, "Center");
    f.setSize(100, 60);
    f.setVisible(true);
    MyThreadViewer.view();
  }
}
class MyMonitor extends WindowAdapter implements ActionListener {
  public void actionPerformed(ActionEvent e) {
    MyThreadViewer.view();
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{GUI线程}

\samp{TestGUIThread.java: Part 2}
\begin{javaCode}
class MyThreadViewer {
  public static void view() {
    Thread current = Thread.currentThread();
    System.out.println("当前线程名称：" + current.getName());
    int total = Thread.activeCount();
    System.out.println("活动线程总数：" + total + "个");
    Thread[] threads = new Thread[total];
    current.enumerate(threads);
    for(Thread t: threads) {
      String role = t.isDaemon() ? "后台线程" : "用户线程";
      System.out.println("   -" + role + t.getName());
    }
    System.out.println("-------------------");
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{GUI线程}

\xyy{[API] Thread.enumerate}\\
Copies into the specified array every active thread in the current thread's thread group
and its subgroups. This method simply calls the enumerate method of the current thread's
thread group with the array argument.

First, if there is a security manager, that enumerate method calls the security
manager's checkAccess method with the thread group as its argument. This may result in
throwing a SecurityException.

Parameters: 
\begin{itemize}
\item tarray an array of Thread objects to copy to
\end{itemize}
Returns: 
\begin{itemize}
\item the number of threads put into the array
\end{itemize}
Throws:
\begin{itemize}
\item SecurityException - if a security manager exists and its checkAccess method
  doesn't allow the operation.
\end{itemize}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{GUI自动创建的线程}
\begin{itemize}[<+-| alert@+>]
\item {\hei AWT-Windows线程}\\
  \only<1>{负责从操作系统获取底层事件通知，并将之发送到系统事件队列（EventQueue）等待处理。
    在其他平台上运行时，此线程的名字也会作相应变化，例如在Unix系统则为“AWT-Unix”。}
\item {\hei AWT-EventQueue-n线程}\\
  \only<2>{也称事件分派线程，该线程负责从事件队列中获取事件，将之分派到相应的GUI组件（事
    件源）上，进而触发各种GUI事件处理对象，并将之传递给相应的事件监听器进行处理。}
\item {\hei AWT-Shutdown线程}\\
\only<3>{负责关闭已启用的抽象窗口工具，释放其所占用的资源，该线程将等到其他GUI线程均退出
  后才开始其清理工作。}
\item {\hei DestroyJavaVM线程}\\
\only<4>{在所有其他用户线程退出后，负责释放任意线程所占用系统资源并卸载Java虚拟机。该线
  程在主线程运行结束时由系统自动启动，但要等到所有其他用户线程均退出后才开始其卸载工作。}
\end{itemize}
\end{frame}

\section{线程控制}
% \subsection{线程生命的周期}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程的生命周期}

\begin{itemize}
\item 新建状态——调用Thread构造方法，未显式调用start()方法前；
\item 就绪状态——调用start()方法后，线程在就绪队列里等候；
\item 运行状态——开始执行线程体代码；
\item 阻塞状态——因某事件发生，例如线程进行I/O操作，等待用户输入数据；
\item 终止状态——线程run()方法执行完毕。
\end{itemize}
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{fig02.pdf}
\end{figure}
\end{frame}

% \subsection{线程优先级}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程优先级}

线程的优先级用数字来表示，范围从1到10。主线程的缺省优先级是5，子线程的优先级默认与其父线
程相同。可以使用Thread类的下述方法获得和设置线程的优先级。
\begin{itemize}
\item 获取当前线程优先级
  \begin{javaCode}
    public final int getPriority();
  \end{javaCode}
\item 设定当前线程优先级
  \begin{javaCode}
    public final void setPriority(int newPriority);
  \end{javaCode}
\end{itemize}
相关静态整型常量：
\begin{javaCode}
Thread.MIN_PRIORITY = 1
Thread.MAX_PRIORITY = 10
Thread.NORM_PRIORITY = 5
\end{javaCode}
\cxf{练习} 请自行编写线程优先级测试代码。
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程串行化}

在多线程程序中，如果在一个线程运行的过程中要用到另一个线程的运行结果，则可进行线程的串型
化处理。

Thread类提供的相关方法：
\begin{javaCode}
public final void join()
public final void join(long millis)
public final void join(long millis, int nanos)
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程串行化}
\xyy{实现线程的串行化}
\samp{TestJoin.java}
\begin{javaCode}
public class TestJoin {
  public static void main(String[] args) {
    MyRunner r = new MyRunner();
    Thread t = new Thread(r);
    t.start();
    try {
      t.join();
    } catch(InterruptedException e) {
      e.printStackTrace();
    }
    for(int i = 0; i < 50; i++) {
      System.out.println("主线程：" + i);
    }
  }
}
class MyRunner implements Runable {
  public void run() {
    for(int i = 0; i < 50; i++) {
      System.out.println("子线程：" + i);
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程串行化}

上述程序，主线程在执行过程中调用了线程t的join()方法，该方法导致当前线程（主线程）阻塞，直
到线程t运行终止后，主线程才会获得继续执行的机会。这相当于将线程t串行加入到主线程中。
\end{frame}

% \subsection{线程休眠}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程休眠}
线程休眠，即暂停执行当前运行中的线程，使之进入阻塞状态，待经过指定的“延
迟时间”后再醒来并转入到就绪状态。

Thread类提供的相关方法：
\begin{javaCode}
public static void sleep(long millis)
public static void sleep(long millis, int nanos)
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程休眠}
\xyy{数字计数器}
\samp{Digitaltimer.java}
\begin{javaCode}
import java.util.Calendar;
import java.util.GregorianCalendar;
import javax.swing.*;

public class DigitalClock {
  public static void main(String[] args) {
    JFrame jf = new JFrame("Clock");
    JLabel clock = new JLabel("clock");
    clock.setHorizontalAlignment(JLabel.CENTER);
    jf.add(clock, "Center");
    jf.setSize(140, 80);
    jf.setLocation(500, 300);
    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    jf.setVisible(true);
    Thread t = new MyThread(clock);
    t.start();
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程休眠}
\samp{DigitalTimer.java+}
\begin{javaCode}
class MyThread extends Thread {
  private JLabel clock;
  private int i;
  public MyThread(JLabel clock) {
    this.clock = clock;
    this.i = 1;
  }
  public void run() {
    while(true) {
      clock.setText(String.valueOf(i++));
      try {
        Thread.sleep(1000);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}  
\end{javaCode}
\end{frame}

% \subsection{线程让步}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程让步}

线程让步，让运行中的线程主动放弃当前获得的CPU处理机会，但不是使该线程阻塞，而是使之转入就
绪状态。

Thread类提供的相关方法：
\begin{javaCode}
public static void yield()  
\end{javaCode}
\xyy{线程让步示例}
\samp{TestYield.java}
\begin{javaCode}
import java.util.Date;

public class TestYield {
  public static void main(String[] args) {
    Thread t1 = new MyThread(false);
    Thread t2 = new MyThread(true);
    Thread t3 = new MyThread(false);
    t1.start();
    t2.start();
    t3.start();
  }
}
\end{javaCode}
\end{frame}

\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程让步}

\samp{TestYield.java+}
\begin{javaCode}
class MyThread extends Thread {
  private boolean flag;
  public MyThread(boolean flag) {
    this.flag = flag;
  }
  public void setFlag(boolean flag) {
    this.flag = flag;
  }
  public void run() {
    long start = new Date().getTime();
    for(int i = 0; i < 200; i++) {
      if(flag) {
        Thread.yield();
      }
      System.out.println(this.getName() + ": " + i + "\t");
    }
    long end = new Date().getTime();
    System.out.println("\n" + this.getName() + "执行时间：" + (end - start) + "ms");
  }
}
\end{javaCode}

从执行结果来看，由于设置了线程让步，thread-1（第二个线程）明显执行时间长。
调用yield()方法只是令当前线程主动在时间片到期前使其他线程获得运行机会。
\end{frame}

% \subsection{线程挂起与恢复}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程挂起与恢复}

\begin{description}
\item[线程挂起] 暂时停止当前运行中的线程，使之转入阻塞状态，并且不会自动恢复运行。
\item[线程恢复] 使得一个已挂起的线程恢复运行。
\end{description}
Thread类提供的相关方法：
\begin{javaCode}
public final void suspend()
public final void resume()
\end{javaCode}
suspend()和resume()方法已不提倡使用，原因是：suspend()方法挂起线程时并不释放其锁定的资
源，这可能会影响到其他线程的执行，且容易导致线程死锁。
\end{frame}

% \subsection{线程等待与通知}
\begin{frame}[fragile] % [fragile]参数使得能够插入代码
\frametitle{线程等待与通知}

\wxd{将运行中的线程专为阻塞状态的另外一种途径}

调用该线程中被锁定资源（Java对象）的wait()方法，该方法在Object类中定义，其功能是让当前线
程等待，直到有其他线程调用了同一个对象的notify()或notifyAll()方法通知其结束等待，或是经历
了约定的等待时间后，等待线程才会醒来，重新进入可执行状态。

\wxd{等待线程与suspend()方法导致的线程挂起比较}
\begin{itemize}
\item 线程挂起时不会释放所占用的资源；
\item 线程等待时则会释放资源，以使其他线程获得运行机会。
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

% \section{线程的同步}
% \subsection{临界资源问题}
% \subsection{互斥锁}
% \subsection{死锁}
% \subsection{线程同步通讯}
% \subsection{生产者—消费者问题}
% \section{多线程编程专题}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \begin{frame}
%% \frametitle{本章习题}
%% \begin{enumerate}
%% \item a
%% \item b
%% \end{enumerate}
%% \end{frame}

%% \begin{figure}
%% \centering
%% \includegraphics[width=0.6\textwidth]{fig01.png}
%% \end{figure}
% TKS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\centering
{\Huge \textcolor{blue}{THE END}} \\
\vspace{5mm}
{\Large wxd2870@163.com} \\
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
